import sys
import numpy as np
import time
import matplotlib.pyplot as plt
from matplotlib.widgets import Button
from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable
import os
import yaml
import inspect
try:
    import pyqtgraph as pqt
    from pyqtgraph.Qt import QtCore, QtGui, QtWidgets
    PYQTGRAPH_INSTALLED = True
except ImportError:
    from PyQt5 import QtCore, QtGui, QtWidgets # can replace pyqtgraph
    PYQTGRAPH_INSTALLED = False
from threading import Event
from generic_logging import quick_config
import logging
sys.path.append(r'C:\Program Files (x86)\Keysight\SD1\Libraries\Python')
import keysightSD1
try:
    import keysight_tse as kthvi
except ImportError:
    import keysight_hvi as kthvi
from KS2201A_lib import ModuleDescriptor, open_modules, configure_awg, configure_digitizer, \
                        calc_slewTimer, calc_step_counter, define_hvi_resources, convertFloatingPointToInteger, \
                        program_step_to_target_voltage, digitizer_measurement_chx, export_hvi_sequences, \
                        load_awg, load_digitizer, instruction_name, send_CC_matrix, \
                        Module, read_channel_voltage, verify_sweep_parameters_1d, set_hvi_done, \
                        initialize_logging, calc_num_cycles_per_segment
from file_save_system import create_save_filename
from firmware_manager import FirmwareVersionTracker

#%% Config
class ApplicationConfig1D:
    " Defines module descriptors, configuration options and names of HVI engines, actions, triggers"
    def __init__(self, log_dir, chassis_list, module_descriptors, vi_1d, vf_1d, num_steps_1d, AWG_channel_1d = 1, slew_rate_1d = 1, integration_time = 10000, prescaler = 4, dV=45.7778e-6,
                 loadBitstream=False, load_digitizer_channel_config = False, use_QD_emulator = False, QD_emulator_Cm=0.2, use_virtual_gates=False, hardware_simulated=False, start_logging=True): 

        if start_logging:
            day_folder, _ = create_save_filename(log_dir, "Sweeper1D")
            self.logger, self.console_handler, self.file_handler = initialize_logging(day_folder, "Sweeper1D")

        """
        Define PXI instruments options
        """
        # Define options to open the instruments.
        # Complete option list can be found in the SD1 3.x User Guide
        self.hardware_simulated = hardware_simulated
        
        """
        Define names of HVI engines, actions, registers
        """
        # HVI engine names to be used in this application
        self.main_awg_engine_name = None
        self.main_dig_engine_name = None

        # HVI action names to be used by each HVI engine
        self.awg_trigger_name = "AWG_Trigger"
        self.daq_trigger_name = "DAQ_Trigger"

        # HVI register names to be used within the scope of each HVI engine
        # self.voltage_chx_name = "Voltage Ch{}"
        self.voltage_1d_name = "Voltage 1D (Ch{})"
        self.vg_voltage_1d_name = "VG Voltage 1D (Ch{})" # used to save the voltage set by the sweeping module for virtual gates
        self.vi_1d_name = "Vi 1D"
        self.vf_1d_name = "Vf 1D"
        # self.slew_time_name = "Slew Time" # the register is reused and updated before all voltages ramps
        self.ramp_counter_1d_name = "Ramp Counter 1D"
        self.awg_loop_counter_1d_name = "AWG Loop Counter 1D"
        self.voltage_increment_name = "Voltage Increment"
        self.neg_voltage_increment_name = "Neg Voltage Increment"
        self.sweep_direction_name = "Sweep Direction" # positive or negative
        self.neg_counter_name = "Neg Counter" # increment if VchX and/or Vi is negative
        self.awg_debug_name = "AWG Debug" # register used to debug

        self.stabilization_time_name = "Stabilization Time"
        self.integration_pause_time_name = "Integration and Pause Time"
        self.loop_counter_1d_name = "Loop Counter 1D"
        self.step_counter_1d_name = "Step Counter 1D"
        self.num_cycles_seg_name = "Num Cycles in Seg"
        self.num_cycles_since_config_name = "Num Cycles Since Config"
        self.hvi_done_name = "HVI Done"
        self.dig_debug_name = "DIG Debug"
        
        self.instruction_name = instruction_name() # class to generate unique names for instructions

        self.debug_var = None

        """
        Define names of FPGA sandbox resources
        """
        # Bitstream files generated by compiling PathWave FPGA project files
        self.fw_database = FirmwareVersionTracker()
        self.fw_database.load_database()

        self.M3202A_voltage_registers_firmware = self.fw_database.get_fw("Voltage_registers_firmware_SD1_HVI", "M3202A", "04.03.00")
        self.M3201A_voltage_registers_firmware = self.fw_database.get_fw("Voltage_registers_firmware_SD1_HVI", "M3201A", "04.04.00")
        self.M3202A_virtual_gates_firmware = self.fw_database.get_fw("M3202A_virtual_gates_firmware", "M3202A", "04.03.00") # offset and waveform
        self.M3202A_VG_CC8_card1_voltreg_firmware = self.fw_database.get_fw("VG_CC8_card1_v3_firmware", "M3202A", "04.03.00")
        self.M3202A_VG_CC8_card2_voltreg_firmware = self.fw_database.get_fw("VG_CC8_card2_v3_firmware", "M3202A", "04.03.00")
        self.M3202A_VG_CC8_firmware_list = [self.M3202A_voltage_registers_firmware, self.M3202A_VG_CC8_card1_voltreg_firmware, self.M3202A_VG_CC8_card2_voltreg_firmware]
        self.M3201A_VG_CC8_card1_voltreg_firmware = self.fw_database.get_fw("VG_CC8_card1_v3_firmware", "M3201A", "04.04.00")
        self.M3201A_VG_CC8_card2_voltreg_firmware = self.fw_database.get_fw("VG_CC8_card2_v3_firmware", "M3201A", "04.04.00")
        self.M3201A_VG_CC8_firmware_list = [self.M3201A_voltage_registers_firmware, self.M3201A_VG_CC8_card1_voltreg_firmware, self.M3201A_VG_CC8_card2_voltreg_firmware]
        self.M3202A_VG_CC12_card1_voltreg_firmware = self.fw_database.get_fw("VG_CC12_card1_v3_firmware", "M3202A", "04.03.00")
        self.M3202A_VG_CC12_card2_voltreg_firmware = self.fw_database.get_fw("VG_CC12_card2_v3_firmware", "M3202A", "04.03.00")
        self.M3202A_VG_CC12_card3_voltreg_firmware = self.fw_database.get_fw("VG_CC12_card3_v3_firmware", "M3202A", "04.03.00")
        self.M3202A_VG_CC12_firmware_list = [self.M3202A_voltage_registers_firmware, self.M3202A_VG_CC12_card1_voltreg_firmware, self.M3202A_VG_CC12_card2_voltreg_firmware, self.M3202A_VG_CC12_card3_voltreg_firmware]
        self.M3100A_default_firmware = self.fw_database.get_fw("Digitizer_default_firmware", "M3100A", "02.03.00")
        self.QD_emulator_firmware  = self.fw_database.get_fw("QD_emulator_firmware_Cm_variable", "M3100A", "02.03.00")

        # Sandbox name defined by each instrument. See SD1 3.x User Guide for further info
        self.M3xxxA_sandbox = "sandbox0" # The M3xxxA_sandbox name is not arbitrary and cannot be changed
        # FPGA Sandbox resource names
        # NOTE The FPGA resource names are not arbitrary. They correspond to the names defined in the PathWave FPGA project files
        self.fpga_voltage_chx_name = "Voltage_registers_V_Ch{}"
        self.fpga_voltage_ch1_name = "Voltage_registers_V_Ch1"
        self.fpga_voltage_ch2_name = "Voltage_registers_V_Ch2"
        self.fpga_voltage_ch3_name = "Voltage_registers_V_Ch3"
        self.fpga_voltage_ch4_name = "Voltage_registers_V_Ch4"
        self.fpga_debug_name = "Voltage_registers_Debug"

        self.VG_memory_map_name = "Host_1" # Host is accessible from the PC, MainEngine_Memory accessible from HVI 2

        self.MemoryEngine_QD_emulator_name = "MainEngine_Memory_1"
        self.HLS_start_name = "HLS start"
        self.Cm_value_name = "Cm value"

        """
        Define HW Platform
        """
        # Define module descriptors below with your instruments information
        self.module_descriptors = module_descriptors

        # Define list of chassis containing instruments to be used by HVI
        self.chassis_list = chassis_list

        # Multi-chassis setup
        # In case of multiple chassis, chassis PXI lines need to be shared using M9031 PXI modules.
        # In case of single-chassis setup please leave the list empty: M9031_descriptors = []
        self.M9031_descriptors = []

        # Assign triggers to HVI object to be used for HVI-managed synchronization, data sharing, etc
        # NOTE: In a multi-chassis setup ALL the PXI lines listed below need to be shared among each M9031 board pair by means of SMB cable connections
        self.pxi_sync_trigger_resources = [
            kthvi.TriggerResourceId.PXI_TRIGGER0]
        
        """
        Defines the experiment parameters
        """
        self.loadBitstream = loadBitstream
        self.load_digitizer_channel_config = load_digitizer_channel_config
        self.use_virtual_gates = use_virtual_gates
        self.use_QD_emulator = use_QD_emulator
        self.AWG_channel_1d = AWG_channel_1d
        self.vi_1d = vi_1d
        self.vf_1d = vf_1d
        self.slew_rate_1d = slew_rate_1d # 0.08 for real-time logging # 220e-6 (around 2s wait) # 2 V/s
        self.num_steps_1d = num_steps_1d
        self.dV = dV
        self.QD_emulator_Cm = QD_emulator_Cm
        if self.use_QD_emulator == True:
            self.stabilization_time = 1e-6
        else:
            self.stabilization_time = 1e-3
        self.pause_time = 0
        self.max_time = 30 # Maximum time in between data acquisitions before timeout
        self.print_interval = 0.3 # 0 for real-time logging in interact_with_hvi

        """
        AWG parameters
        """
        # self.all_ch_mask = 0xF # binary mask defining which channels to use
        # AWG settings for all channels
        self.sync_mode = keysightSD1.SD_SyncModes.SYNC_NONE # synchronized to CLKSYS
        self.queue_mode = keysightSD1.SD_QueueMode.ONE_SHOT
        self.awg_mode = keysightSD1.SD_Waveshapes.AOU_AWG
        self.start_delay = 0 # x10 [ns]
        self.awg_prescaler = 0
        self.amplitude = 1 # [V]
        # self.offset = 0 # [V]

        # Trigger settings
        self.awg_trigger_mode = keysightSD1.SD_TriggerModes.SWHVITRIG_CYCLE
        # Latency values for M3202A AWGqueueWfm() [ns]
        # Latencies depend on AWG FPGA FW. Please check the SD1 3.x User Guide for detailed info
        # self.queue_wfm_latency = 100 # [ns] Minimum start delay necessary to execute an AWGqueueWfm() instruction
        # self.awg_trigger_latency = 2300 # [ns] Minimum latency necessary between an AWGqueueWfm() instruction and an AWGtrigger action.

        """
        Digitizer parameters
        """
        self.integration_time_input = integration_time
        self.dig_prescaler = prescaler # fs = fCLKsys / (1 + prescaler)
        self.fullscale = 4 # [V] enter x Volts to set the full scale to [-x, x] Volts
        self.acquisition_delay = 0 # x2[ns]
        self.dig_trigger_mode = keysightSD1.SD_TriggerModes.SWHVITRIG
        self.hvi_clock_cycle = 10 # [ns]

    @classmethod
    def from_yaml(cls, yaml_file):
        with open(yaml_file, 'r') as file:
            data = yaml.safe_load(file)

        # Check how many AWG modules are used for virtual gates
        nb_VG_awg_modules = 0
        for key in data.keys():
            if "awg_descriptor" in key:
                card_num_VG = data[key]["card_num_VG"]
                if card_num_VG > 0:
                    nb_VG_awg_modules += 1

        if nb_VG_awg_modules > 3: raise NotImplementedError("Only 3 AWG modules can be used for virtual gates for now.")

        config_data = data["ApplicationConfig"]
        awg_chassis = data["main_awg_descriptor"]["chassis_number"]
        dig_chassis = data["digitizer_descriptor"]["chassis_number"]
        log_dir = config_data["log_dir"]

        # Get expected arguments from class
        expected_args = inspect.getfullargspec(cls.__init__).args

        # Remove excess arguments from config_data
        new_config_data = {key: config_data[key] for key in expected_args if key != "self" and key != "chassis_list" and key != "module_descriptors" and key != "start_logging"}
            
        # Create chassis_list
        chassis_list = sorted(list(set([awg_chassis, dig_chassis]))) # remove duplicates with set

        # Create module_descriptors
        awg_descriptor = ModuleDescriptor.from_dict(data["main_awg_descriptor"])
        dig_descriptor = ModuleDescriptor.from_dict(data["digitizer_descriptor"])
        module_descriptors= [awg_descriptor, dig_descriptor]

        config = cls(log_dir, chassis_list, module_descriptors, new_config_data["vi_1d"], new_config_data["vf_1d"], new_config_data["num_steps_1d"], new_config_data["AWG_channel_1d"], new_config_data["slew_rate_1d"], new_config_data["integration_time"], new_config_data["prescaler"], new_config_data["dV"], new_config_data["loadBitstream"], new_config_data["load_digitizer_channel_config"], new_config_data["use_QD_emulator"], new_config_data["QD_emulator_Cm"], new_config_data["use_virtual_gates"], new_config_data["hardware_simulated"])
        warnings = verify_sweep_parameters_1d(config, silence_warnings=True, auto_fix=True)
        config.logger.info("1D sweep parameters warnings: {}".format(warnings))

        # Define main AWG and digitizer engine names
        config.main_awg_engine_name = awg_descriptor.engine_name
        config.main_dig_engine_name = dig_descriptor.engine_name

        # Define database_folder, save_filename and other parameters
        config.database_folder = config_data["database_folder"]
        config.save_filename = config_data["save_filename"]
        config.max_time = config_data["max_time"]
        config.stabilization_time = config_data["stabilization_time"]
        config.fullscale = config_data["fullscale"]

        # Add number of virtual gates modules to config
        config.nb_VG_awg_modules = nb_VG_awg_modules

        # Update yaml file with verified_num_steps_1d
        with open(yaml_file, 'r+') as file:
            lines = file.readlines()
            for i, line in enumerate(lines):
                if "verified_num_steps_1d" in line:
                    split_line = line.split(":")
                    split_value = split_line[1].split(" ") # verified_num_steps_1d = split_value[1]

                    # Recombine the split line
                    split_value[1] = str(config.num_steps_1d)
                    split_line[1] = " ".join(split_value)
                    lines[i] = ":".join(split_line)

            # Write the updated lines to the file
            file.seek(0)
            file.writelines(lines)

        # Add YAML config filename to config
        config.yaml_file = yaml_file

        return config
    
    @property
    def vi_1d_internal(self):
        # Divide by 2 since AWG is outputing twice the voltage on HZ loads
        return self.vi_1d/2.0
    @property
    def vf_1d_internal(self):
        # Divide by 2 since AWG is outputing twice the voltage on HZ loads
        return self.vf_1d/2.0

    @property
    def integration_time(self):
        if self.integration_time_input  < 1500:
            return_value = 1500 # To avoid ERROR : Number of Points per Cycle for DaqConfig Instruction is Out of Range
            self.logger.warning("WARNING: Integration time too short. Setting integration time to 1500 ns.")
            self.integration_time_input = return_value
        else:
            return_value = self.integration_time_input  # [ns] time window to be acquired by DAQ channel each time a DAQ trigger is sent out
        
        return return_value
    
    @property
    def sampling_time(self):
        if self.use_QD_emulator:
            if self.dig_prescaler == 0:
                return 50 # [ns] 1/sample_rate, sample_rate = 500 MSa/s for Digitizer M3102A, sample_rate = 100 MSa/s for Digitizer M3100A, 20MSa/s for QD emulator
            else:
                raise NotImplementedError("QD emulator not tested with prescaler other than 0.")
                # return 50*(5*self.dig_prescaler)
        else:
            if self.dig_prescaler == 0:
                return 10
            else:
                return 10*(1+self.dig_prescaler)
        
    @property
    def acquisition_points_per_cycle(self):
        nb_points = int(self.integration_time / self.sampling_time)
        # If the number of points is not even, reduce by 1 to avoid digitizer warning
        if nb_points % 2 != 0:
            nb_points -= 1
        return nb_points # [Sa]
    @property
    def acquisition_points(self):
        return self.acquisition_points_per_cycle*self.num_cycles
    @property
    def integration_cycles(self):
        return int(np.ceil(self.integration_time / self.hvi_clock_cycle))
    @property
    def stabilization_cycles(self):
        return int(np.ceil(self.stabilization_time / (self.hvi_clock_cycle)))
    @property
    def pause_cycles(self): 
        return int(np.ceil(self.pause_time / self.hvi_clock_cycle))
    @property
    def num_cycles(self):
        return self.num_steps_1d # insert -1 for infinite cycles
    
    def __str__(self):
        return  "chassis_list={}, module_descriptors={}\n" \
                "ApplicationConfig1D(vi_1d={}, vf_1d={}, num_steps_1d={}, AWG_channel_1d={}, slew_rate_1d={}, integration_time={}, stabilization_time={}, dig_prescaler={}, dV={}, loadBitstream={}, load_digitizer_channel_config={}, use_QD_emulator={}, QD_emulator_Cm={}, use_virtual_gates={}, hardware_simulated={})".format(
                self.chassis_list, self.module_descriptors, self.vi_1d, self.vf_1d, self.num_steps_1d, self.AWG_channel_1d, self.slew_rate_1d, self.integration_time, self.stabilization_time, self.dig_prescaler, self.dV, self.loadBitstream, self.load_digitizer_channel_config, self.use_QD_emulator, self.QD_emulator_Cm, self.use_virtual_gates, self.hardware_simulated)

    def __repr__(self):
        return self.__str__()
    
    def __del__(self):
        self.console_handler.close()
        self.logger.removeHandler(self.console_handler)
        self.file_handler.close()
        self.logger.removeHandler(self.file_handler)

    
#%% 2nd Level: Functions to Define, Program, Execute HVI
########################################################

def define_awg_registers_1d(sequencer, awg_module: Module, config):
    """
    Define the awg registers for the module's HVI engine in the scope of the global sync sequence.

    Parameters
    ----------
    sequencer : kthvi.Sequencer
        HVI sequencer object.
    awg_module : Module
        AWG module object.
    config : ApplicationConfig1D
        Configuration of the HVI program.
    """
    awg_engine_name = awg_module.engine_name

    # voltage 1D
    sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.voltage_1d_name.format(config.AWG_channel_1d), kthvi.RegisterSize.SHORT)
    sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.vg_voltage_1d_name.format(config.AWG_channel_1d), kthvi.RegisterSize.SHORT)

    vi_1d = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.vi_1d_name, kthvi.RegisterSize.SHORT)
    vi_1d.initial_value = awg_module.instrument.voltsToInt(config.vi_1d_internal)
    vf_1d = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.vf_1d_name, kthvi.RegisterSize.SHORT)
    vf_1d.initial_value = awg_module.instrument.voltsToInt(config.vf_1d_internal)


    # slew_time = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.slew_time_name, kthvi.RegisterSize.SHORT)
    # slew_time.initial_value = calc_slewTimer(config.vi_1d_internal, config.vf_1d_internal, config.slew_rate_1d, dV=config.dV)
    config.logger.info("Vi 1D: {}={}".format(config.vi_1d_internal, awg_module.instrument.voltsToInt(config.vi_1d_internal)))
    config.logger.info("Vf 1D: {}={}".format(config.vf_1d_internal, awg_module.instrument.voltsToInt(config.vf_1d_internal)))
    config.logger.info("Num steps 1D: {}".format(config.num_steps_1d))
    config.logger.info("Slew Timer: {}".format(calc_slewTimer(config.vi_1d_internal, config.vf_1d_internal, config.slew_rate_1d, dV=config.dV)))

    # sweep_direction
    sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.sweep_direction_name, kthvi.RegisterSize.SHORT)

    neg_counter = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.neg_counter_name, kthvi.RegisterSize.SHORT)
    neg_counter.initial_value = 0

    # awg_debug = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.awg_debug_name, kthvi.RegisterSize.SHORT)
    # awg_debug.initial_value = 0

    awg_loop_counter_1d = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.awg_loop_counter_1d_name, kthvi.RegisterSize.SHORT)
    awg_loop_counter_1d.initial_value = 0
    ramp_counter_1d = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.ramp_counter_1d_name, kthvi.RegisterSize.SHORT)
    ramp_counter = calc_step_counter(config.vi_1d_internal, config.vf_1d_internal, 2, dV=config.dV)
    ramp_counter_1d.initial_value = ramp_counter
    voltage_increment = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.voltage_increment_name, kthvi.RegisterSize.SHORT)
    voltage_increment.initial_value = awg_module.instrument.voltsToInt(config.dV)
    neg_voltage_increment = sequencer.sync_sequence.scopes[awg_engine_name].registers.add(config.neg_voltage_increment_name, kthvi.RegisterSize.SHORT)
    neg_voltage_increment.initial_value = awg_module.instrument.voltsToInt(-1*config.dV)
    config.logger.info("Ramp counter 1d: {}".format(ramp_counter))
    config.logger.info("Voltage increment: {}".format(awg_module.instrument.voltsToInt(config.dV)))


def define_dig_registers_1d(sequencer, dig_module: Module, config):
    """
    Define the digitizer registers for the module's HVI engine in the scope of the global sync sequence.

    Parameters
    ----------
    sequencer : kthvi.Sequencer
        HVI sequencer object.
    dig_module : Module
        Digitizer module object.
    config : ApplicationConfig1D
        Configuration of the HVI program.
    """
    dig_engine_name = dig_module.engine_name

    # Digitizer registers
    stabilization_time = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.stabilization_time_name, kthvi.RegisterSize.SHORT)
    stabilization_time.initial_value = config.stabilization_cycles
    integration_pause_time = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.integration_pause_time_name, kthvi.RegisterSize.SHORT)
    integration_pause_time.initial_value = config.integration_cycles + config.pause_cycles
    loop_counter_1d = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.loop_counter_1d_name, kthvi.RegisterSize.SHORT)
    loop_counter_1d.initial_value = 0

    dig_debug = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.dig_debug_name, kthvi.RegisterSize.SHORT)
    dig_debug.initial_value = 0

    step_counter_1d = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.step_counter_1d_name, kthvi.RegisterSize.SHORT)
    step_counter = calc_step_counter(config.vi_1d_internal, config.vf_1d_internal, config.num_steps_1d, dV=config.dV)
    step_counter_1d.initial_value = step_counter
    config.logger.info("Step counter 1d: {}".format(step_counter))

    # QD emulator registers
    Cm_value = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.Cm_value_name, kthvi.RegisterSize.SHORT)
    Cm_value.initial_value = convertFloatingPointToInteger(config.QD_emulator_Cm)

    hvi_done = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.hvi_done_name, kthvi.RegisterSize.SHORT)
    hvi_done.initial_value = 0

    # registers used to split long measurements into segments
    num_cycles_seg = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.num_cycles_seg_name, kthvi.RegisterSize.SHORT)
    num_cycles_seg.initial_value = calc_num_cycles_per_segment(config.num_cycles, config.acquisition_points_per_cycle, config.use_QD_emulator)[0]
    num_cycles_since_config = sequencer.sync_sequence.scopes[dig_engine_name].registers.add(config.num_cycles_since_config_name, kthvi.RegisterSize.SHORT)
    num_cycles_since_config.initial_value = 0 # to be reset by PC after DAQconfig


def update_awg_registers_1d(hvi, awg_module, config, module_dict):
    """
    Update the 1D sweep AWG registers of the module's HVI engine in the scope of the global sync sequence.

    Parameters
    ----------
    hvi : kthvi.Hvi
        HVI object.
    awg_module : Module
        AWG module object.
    config : ApplicationConfig1D
        Configuration of the HVI program.
    module_dict : dict
        Dictionary containing all the modules used in the HVI program. Used here only for virtual gates.
    """
    # AWG registers
    awg_engine_name = awg_module.engine_name

    vi_1d = hvi.sync_sequence.scopes[awg_engine_name].registers[config.vi_1d_name]
    vi_1d.initial_value = awg_module.instrument.voltsToInt(config.vi_1d_internal)
    vf_1d = hvi.sync_sequence.scopes[awg_engine_name].registers[config.vf_1d_name]
    vf_1d.initial_value = awg_module.instrument.voltsToInt(config.vf_1d_internal)

    if config.use_virtual_gates:
        secondary_awg_module = module_dict[config.secondary_awg_engine_name]
        v_2d, v_2d_int = read_channel_voltage(config.AWG_channel_2d, secondary_awg_module, HZ=False)
        vg_v_2d = hvi.sync_sequence.scopes[awg_engine_name].registers[config.vg_voltage_2d_name.format(config.AWG_channel_2d)]
        vg_v_2d.initial_value = v_2d_int

        # Update the voltage register on the vg modules
        for vg_module_descriptor in config.vg_module_descriptor_list:
            vg_v_2d = hvi.sync_sequence.scopes[vg_module_descriptor.engine_name].registers[config.vg_voltage_2d_name.format(config.AWG_channel_2d)]
            vg_v_2d.initial_value = v_2d_int

    # slew_time = hvi.sync_sequence.scopes[awg_engine_name].registers[config.slew_time_name]
    # slew_time.initial_value = calc_slewTimer(config.vi_1d_internal, config.vf_1d_internal, config.slew_rate_1d, dV=config.dV)

    neg_counter = hvi.sync_sequence.scopes[awg_engine_name].registers[config.neg_counter_name]
    neg_counter.initial_value = 0

    awg_loop_counter_1d = hvi.sync_sequence.scopes[awg_engine_name].registers[config.awg_loop_counter_1d_name]
    awg_loop_counter_1d.initial_value = 0
    ramp_counter_1d = hvi.sync_sequence.scopes[awg_engine_name].registers[config.ramp_counter_1d_name]
    ramp_counter = calc_step_counter(config.vi_1d_internal, config.vf_1d_internal, 2, dV=config.dV)
    ramp_counter_1d.initial_value = ramp_counter
    voltage_increment = hvi.sync_sequence.scopes[awg_engine_name].registers[config.voltage_increment_name]
    voltage_increment.initial_value = awg_module.instrument.voltsToInt(config.dV)
    neg_voltage_increment = hvi.sync_sequence.scopes[awg_engine_name].registers[config.neg_voltage_increment_name]
    neg_voltage_increment.initial_value = awg_module.instrument.voltsToInt(-1*config.dV)

    # awg_debug = hvi.sync_sequence.scopes[awg_engine_name].registers[config.awg_debug_name]
    # awg_debug.initial_value = 0


def update_dig_registers_1d(hvi, dig_module, config):
    """
    Update the 1D sweep digitizer registers of the module's HVI engine in the scope of the global sync sequence.

    Parameters
    ----------
    hvi : kthvi.Hvi
        HVI object.
    dig_module : Module
        Digitizer module object.
    config : ApplicationConfig1D
        Configuration of the HVI program.
    """

    dig_engine_name = dig_module.engine_name

    # Digitizer registers
    stabilization_time = hvi.sync_sequence.scopes[dig_engine_name].registers[config.stabilization_time_name]
    stabilization_time.initial_value = config.stabilization_cycles
    integration_pause_time = hvi.sync_sequence.scopes[dig_engine_name].registers[config.integration_pause_time_name]
    integration_pause_time.initial_value = config.integration_cycles + config.pause_cycles
    loop_counter_1d = hvi.sync_sequence.scopes[dig_engine_name].registers[config.loop_counter_1d_name]
    loop_counter_1d.initial_value = 0

    dig_debug = hvi.sync_sequence.scopes[dig_engine_name].registers[config.dig_debug_name]
    dig_debug.initial_value = 0

    step_counter_1d = hvi.sync_sequence.scopes[dig_engine_name].registers[config.step_counter_1d_name]
    step_counter_1d.initial_value = calc_step_counter(config.vi_1d_internal, config.vf_1d_internal, config.num_steps_1d, dV=config.dV)

    # QD emulator registers
    Cm_value = hvi.sync_sequence.scopes[dig_engine_name].registers[config.Cm_value_name]
    Cm_value.initial_value = convertFloatingPointToInteger(config.QD_emulator_Cm)

    hvi_done = hvi.sync_sequence.scopes[dig_engine_name].registers[config.hvi_done_name]
    hvi_done.initial_value = 0

    # registers used to split long measurements into segments
    num_cycles_seg = hvi.sync_sequence.scopes[dig_engine_name].registers[config.num_cycles_seg_name]
    num_cycles_seg.initial_value = calc_num_cycles_per_segment(config.num_cycles, config.acquisition_points_per_cycle, config.use_QD_emulator)[0]
    num_cycles_since_config = hvi.sync_sequence.scopes[dig_engine_name].registers[config.num_cycles_since_config_name]
    num_cycles_since_config.initial_value = 0 # to be reset by PC after DAQconfig


def initialize_dig_registers_1d(sync_block, dig_module, config):
    """
    Initialize previously defined Digitizer registers
    """
    dig_engine_name = dig_module.engine_name
    dig_sequence = sync_block.sequences[dig_engine_name]

    dig_registers = dig_sequence.scope.registers
    hvi_done = dig_registers[config.hvi_done_name] 
    instruction_label = config.instruction_name.unique("HVI Done = 0")
    instruction = dig_sequence.add_instruction(instruction_label, 10, dig_sequence.instruction_set.assign.id)
    instruction.set_parameter(dig_sequence.instruction_set.assign.destination.id, hvi_done)
    instruction.set_parameter(dig_sequence.instruction_set.assign.source.id, 0)


    if config.use_QD_emulator == True and not config.hardware_simulated:
        instruction_label = config.instruction_name.unique("Write reg_HLS_start = 1")
        writeMemoryMap = dig_sequence.add_instruction(instruction_label, 30, dig_sequence.instruction_set.fpga_array_write.id)
        fpga_memory_map_DIG = dig_sequence.engine.fpga_sandboxes[config.M3xxxA_sandbox].fpga_memory_maps[config.MemoryEngine_QD_emulator_name]
        writeMemoryMap.set_parameter(dig_sequence.instruction_set.fpga_array_write.fpga_memory_map.id, fpga_memory_map_DIG)
        writeMemoryMap.set_parameter(dig_sequence.instruction_set.fpga_array_write.fpga_memory_map_offset.id, 0)
        writeMemoryMap.set_parameter(dig_sequence.instruction_set.fpga_array_write.value.id, 1)

        writeMemoryMap = dig_sequence.add_instruction("Set Cm value", 10, dig_sequence.instruction_set.fpga_array_write.id)
        fpga_memory_map_DIG = dig_sequence.engine.fpga_sandboxes[config.M3xxxA_sandbox].fpga_memory_maps[config.MemoryEngine_QD_emulator_name]
        writeMemoryMap.set_parameter(dig_sequence.instruction_set.fpga_array_write.fpga_memory_map.id, fpga_memory_map_DIG)
        writeMemoryMap.set_parameter(dig_sequence.instruction_set.fpga_array_write.fpga_memory_map_offset.id, 8)
        writeMemoryMap.set_parameter(dig_sequence.instruction_set.fpga_array_write.value.id, dig_sequence.scope.registers[config.Cm_value_name])


def initialize_awg_registers_1d(sync_block, awg_module, config):
    """
    Initialize all registers with their configured values or with values taken from the FPGA memory
    """
    awg_engine_name = awg_module.engine_name
    
    # Read FPGA Register Voltage Ch1 before sweep
    awg_sequence = sync_block.sequences[awg_engine_name]
    
    # Get register values
    awg_registers = awg_sequence.scope.registers
    voltage_channel_1d = awg_registers[config.voltage_1d_name.format(config.AWG_channel_1d)] 
    # awg_debug = awg_registers[config.awg_debug_name]
    # slew_time = awg_registers[config.slew_time_name]
    
    if not config.hardware_simulated:
        # Read FPGA Register Voltage before sweep
        instruction_label = config.instruction_name.unique("Read FPGA Register Bank Voltage_Chx")
        readFpgaReg = awg_sequence.add_instruction(instruction_label, 100, awg_sequence.instruction_set.fpga_register_read.id)
        readFpgaReg.set_parameter(awg_sequence.instruction_set.fpga_register_read.destination.id, voltage_channel_1d)
        fpga_voltage_channel_name = config.fpga_voltage_chx_name.format(config.AWG_channel_1d)
        fpga_voltage = awg_sequence.engine.fpga_sandboxes[config.M3xxxA_sandbox].fpga_registers[fpga_voltage_channel_name]
        readFpgaReg.set_parameter(awg_sequence.instruction_set.fpga_register_read.fpga_register.id, fpga_voltage)
    
    # instruction_label = config.instruction_name.unique("Delay")
    # awg_sequence.add_wait_time(instruction_label, 50, slew_time)
    # awg_sequence.add_delay(instruction_label, round(calc_slewTimer(config.vi_1d_internal, config.vf_1d_internal, config.slew_rate_1d, dV=config.dV)*10))

def sweeper_1d(sequencer, awg_module, dig_module, config, virtual_gates_modules=[]):
    """
    This method programs the HVI sequence for a voltage sweep in 1D.
    Different HVI statements are encapsulated as much as possible in separated SW methods to help users visualize
    the programmed HVI sequences.
    """
    awg_engine_name = awg_module.engine_name
    dig_engine_name = dig_module.engine_name

    # Get register values
    awg_registers = sequencer.sync_sequence.scopes[awg_engine_name].registers
    voltage_channel_1d = awg_registers[config.voltage_1d_name.format(config.AWG_channel_1d)] 
    vi_1d = awg_registers[config.vi_1d_name]
    vf_1d = awg_registers[config.vf_1d_name]
    awg_loop_counter_1d = awg_registers[config.awg_loop_counter_1d_name]
    ramp_counter_1d = awg_registers[config.ramp_counter_1d_name]
    # awg_debug = awg_registers[config.awg_debug_name]

    dig_registers = sequencer.sync_sequence.scopes[dig_engine_name].registers
    loop_counter_1d = dig_registers[config.loop_counter_1d_name]
    dig_debug = dig_registers[config.dig_debug_name]
    step_counter_1d = dig_registers[config.step_counter_1d_name]
    num_cycles_seg = dig_registers[config.num_cycles_seg_name]
    num_cycles_since_config = dig_registers[config.num_cycles_since_config_name]


    ###########################################################################

    # Start by going to initial voltage by increments of 1 (ramp_counter_1d can't be calculated in define_awg_registers_1d for an unknown starting voltage)
    # Configure Sync While Condition
    sync_while_condition = kthvi.Condition.register_comparison(voltage_channel_1d, kthvi.ComparisonOperator.NOT_EQUAL_TO, vi_1d)
    instruction_label = config.instruction_name.unique("While Voltage Chx != Vi 1D")
    sync_while_init = sequencer.sync_sequence.add_sync_while(instruction_label, 570, sync_while_condition)

    # Add a sync block
    instruction_label = config.instruction_name.unique("Go to Vi")
    sync_block = sync_while_init.sync_sequence.add_sync_multi_sequence_block(instruction_label, 260)
    awg_sequence = sync_block.sequences[awg_engine_name]

    voltage_channel = sequencer.sync_sequence.scopes[awg_module.engine_name].registers[config.voltage_1d_name.format(config.AWG_channel_1d)]
    program_step_to_target_voltage(sequencer, awg_module, awg_sequence, config, config.AWG_channel_1d, voltage_channel, vi_1d, config.slew_rate_1d, use_dV_from_config=False)
    if len(virtual_gates_modules) > 0:
        for virtual_gate_module in virtual_gates_modules:
            voltage_channel = sequencer.sync_sequence.scopes[virtual_gate_module.engine_name].registers[config.vg_voltage_1d_name.format(config.AWG_channel_1d)]
            vg_awg_registers = sequencer.sync_sequence.scopes[virtual_gate_module.engine_name].registers
            vg_vi_1d = vg_awg_registers[config.vi_1d_name]
            program_step_to_target_voltage(sequencer, virtual_gate_module, sync_block.sequences[virtual_gate_module.engine_name], config, config.AWG_channel_1d, voltage_channel, vg_vi_1d, config.slew_rate_1d, use_dV_from_config=False, output_voltage=False, source_VG_module=awg_module)

    # Add a sync block
    instruction_label = config.instruction_name.unique("First measurement")
    sync_block = sequencer.sync_sequence.add_sync_multi_sequence_block(instruction_label, 260)

    # Do first measurement at Vi 1D
    dig_sequence = sync_block.sequences[dig_engine_name]
    digitizer_measurement_chx(dig_sequence, config)

    instruction_label = config.instruction_name.unique("Dig debug += 1")
    instruction = dig_sequence.add_instruction(instruction_label, 10, dig_sequence.instruction_set.add.id)
    instruction.set_parameter(dig_sequence.instruction_set.add.destination.id, dig_debug)
    instruction.set_parameter(dig_sequence.instruction_set.add.left_operand.id, dig_debug)
    instruction.set_parameter(dig_sequence.instruction_set.add.right_operand.id, 1)

    instruction_label = config.instruction_name.unique("Num cycles since config += 1")
    instruction = dig_sequence.add_instruction(instruction_label, 10, dig_sequence.instruction_set.add.id)
    instruction.set_parameter(dig_sequence.instruction_set.add.destination.id, num_cycles_since_config)
    instruction.set_parameter(dig_sequence.instruction_set.add.left_operand.id, num_cycles_since_config)
    instruction.set_parameter(dig_sequence.instruction_set.add.right_operand.id, 1)

    # Configure while condition
    while_condition = kthvi.Condition.register_comparison(num_cycles_since_config, kthvi.ComparisonOperator.GREATER_THAN_OR_EQUAL_TO, num_cycles_seg)
    instruction_label = config.instruction_name.unique("If segment measured, wait until PC reset dig config")
    while_loop = dig_sequence.add_while(instruction_label, 100, while_condition)
    # Program local while sequence
    wait = dig_sequence.add_delay("Delay", 100)

    ###########################################################################

    # Configure Sync While Condition
    sync_while_condition = kthvi.Condition.register_comparison(awg_loop_counter_1d, kthvi.ComparisonOperator.LESS_THAN, ramp_counter_1d)
    instruction_label = config.instruction_name.unique("While AWG loop counter 1D < ramp counter 1D")
    sync_while_1D = sequencer.sync_sequence.add_sync_while(instruction_label, 320, sync_while_condition)

    # Add a sync block
    instruction_label = config.instruction_name.unique("Sweep")
    sync_block = sync_while_1D.sync_sequence.add_sync_multi_sequence_block(instruction_label, 260)
    awg_sequence = sync_block.sequences[awg_engine_name]

    # Go to final voltage
    voltage_channel = sequencer.sync_sequence.scopes[awg_module.engine_name].registers[config.voltage_1d_name.format(config.AWG_channel_1d)]
    program_step_to_target_voltage(sequencer, awg_module, awg_sequence, config, config.AWG_channel_1d, voltage_channel, vf_1d, config.slew_rate_1d, use_dV_from_config = True)
    if len(virtual_gates_modules) > 0:
        for virtual_gate_module in virtual_gates_modules:
            voltage_channel = sequencer.sync_sequence.scopes[virtual_gate_module.engine_name].registers[config.vg_voltage_1d_name.format(config.AWG_channel_1d)]
            vg_awg_registers = sequencer.sync_sequence.scopes[virtual_gate_module.engine_name].registers
            vg_vf_1d = vg_awg_registers[config.vf_1d_name]
            program_step_to_target_voltage(sequencer, virtual_gate_module, sync_block.sequences[virtual_gate_module.engine_name], config, config.AWG_channel_1d, voltage_channel, vg_vf_1d, config.slew_rate_1d, use_dV_from_config=False, output_voltage=False, source_VG_module=awg_module)

    # Increment AWG loop counter
    instruction_label = config.instruction_name.unique("AWG loop counter 1D += 1")
    instruction = awg_sequence.add_instruction(instruction_label, 10, awg_sequence.instruction_set.add.id)
    instruction.set_parameter(awg_sequence.instruction_set.add.destination.id, awg_loop_counter_1d)
    instruction.set_parameter(awg_sequence.instruction_set.add.left_operand.id, awg_loop_counter_1d)
    instruction.set_parameter(awg_sequence.instruction_set.add.right_operand.id, 1)

    # instruction_label = config.instruction_name.unique("AWG Debug += 1")
    # instruction = awg_sequence.add_instruction(instruction_label, 10+80, awg_sequence.instruction_set.add.id)
    # instruction.set_parameter(awg_sequence.instruction_set.add.destination.id, awg_debug)
    # instruction.set_parameter(awg_sequence.instruction_set.add.left_operand.id, awg_debug)
    # instruction.set_parameter(awg_sequence.instruction_set.add.right_operand.id, 1)

    # Add a sync block
    instruction_label = config.instruction_name.unique("Reset AWG loop counter 1D")
    sync_block = sequencer.sync_sequence.add_sync_multi_sequence_block(instruction_label, 260)
    awg_sequence = sync_block.sequences[awg_engine_name]

    instruction_label = config.instruction_name.unique("AWG loop counter 1D = 0")
    instruction = awg_sequence.add_instruction(instruction_label, 10, awg_sequence.instruction_set.assign.id)
    instruction.set_parameter(awg_sequence.instruction_set.assign.destination.id, awg_loop_counter_1d)
    instruction.set_parameter(awg_sequence.instruction_set.assign.source.id, 0)

    ###################################

    # Add a sync block
    instruction_label = config.instruction_name.unique("Measure")
    sync_block = sync_while_1D.sync_sequence.add_sync_multi_sequence_block(instruction_label, 100)

    # Measure with digitizer
    dig_sequence = sync_block.sequences[dig_engine_name]

    instruction_label = config.instruction_name.unique("Loop Counter += 1")
    instruction = dig_sequence.add_instruction(instruction_label, 10+80, dig_sequence.instruction_set.add.id)
    instruction.set_parameter(dig_sequence.instruction_set.add.destination.id, loop_counter_1d)
    instruction.set_parameter(dig_sequence.instruction_set.add.left_operand.id, loop_counter_1d)
    instruction.set_parameter(dig_sequence.instruction_set.add.right_operand.id, 1)

    # Check if the loop counter is reached to trigger a measurement
    # Configure IF condition
    if_condition = kthvi.Condition.register_comparison(loop_counter_1d, kthvi.ComparisonOperator.LESS_THAN, step_counter_1d)

    # Add If statement
    enable_ifbranches_time_matching = False # Set flag that enables to match the execution time of all the IF branches
    instruction_label = config.instruction_name.unique("Loop Counter < Step Counter 1D")
    if_statement = dig_sequence.add_if(instruction_label, 70+40, if_condition, enable_ifbranches_time_matching) # 100 ns needed for the loop counter to be updated before condition

    # Program IF branch
    if_sequence = if_statement.if_branch.sequence
    # Add statements in if-sequence

    # instruction_label = config.instruction_name.unique("DIG Debug += 1")
    # instruction = if_sequence.add_instruction(instruction_label, 10+80, if_sequence.instruction_set.add.id)
    # instruction.set_parameter(if_sequence.instruction_set.add.destination.id, dig_debug)
    # instruction.set_parameter(if_sequence.instruction_set.add.left_operand.id, dig_debug)
    # instruction.set_parameter(if_sequence.instruction_set.add.right_operand.id, 1)

    # Else-branch
    # Program Else branch
    else_sequence = if_statement.else_branch.sequence
    # Add statements in Else-sequence
    digitizer_measurement_chx(else_sequence, config)

    instruction_label = config.instruction_name.unique("DIG Debug += 1")
    instruction = else_sequence.add_instruction(instruction_label, 10+80, else_sequence.instruction_set.add.id)
    instruction.set_parameter(else_sequence.instruction_set.add.destination.id, dig_debug)
    instruction.set_parameter(else_sequence.instruction_set.add.left_operand.id, dig_debug)
    instruction.set_parameter(else_sequence.instruction_set.add.right_operand.id, 1)

    instruction_label = config.instruction_name.unique("Num cycles since config += 1")
    instruction = else_sequence.add_instruction(instruction_label, 10, else_sequence.instruction_set.add.id)
    instruction.set_parameter(else_sequence.instruction_set.add.destination.id, num_cycles_since_config)
    instruction.set_parameter(else_sequence.instruction_set.add.left_operand.id, num_cycles_since_config)
    instruction.set_parameter(else_sequence.instruction_set.add.right_operand.id, 1)

    # Configure while condition
    while_condition = kthvi.Condition.register_comparison(num_cycles_since_config, kthvi.ComparisonOperator.GREATER_THAN_OR_EQUAL_TO, num_cycles_seg)
    instruction_label = config.instruction_name.unique("If segment measured, wait until PC reset dig config")
    while_loop = dig_sequence.add_while(instruction_label, 100, while_condition)
    # Program local while sequence
    wait = dig_sequence.add_delay("Delay", 100)


def interact_with_hvi(hvi, awg_module: Module, dig_module: Module, DAQ_channel: int, config, logger, verbose: bool, average_data = True, countdown = True, plot_pyqtgraph=False):
    """
    This SW method compiles HVI, loads it to HW and executes it
    """
    awg_engine_name = awg_module.engine_name
    dig_engine_name = dig_module.engine_name

    # AWG registers
    awg_registers = hvi.sync_sequence.scopes[awg_engine_name].registers
    voltage_channel_1d = awg_registers[config.voltage_1d_name.format(config.AWG_channel_1d)] 
    vi_1d = awg_registers[config.vi_1d_name]
    vf_1d = awg_registers[config.vf_1d_name]
    # slew_time = awg_registers[config.slew_time_name]
    sweep_direction = awg_registers[config.sweep_direction_name]
    neg_counter = awg_registers[config.neg_counter_name]
    # awg_debug = awg_registers[config.awg_debug_name]

    # Dig registers
    dig_registers = hvi.sync_sequence.scopes[dig_engine_name].registers # digitizer registers collection
    loop_counter_1d = dig_registers[config.loop_counter_1d_name]
    dig_debug = dig_registers[config.dig_debug_name]
    step_counter_1d = dig_registers[config.step_counter_1d_name]
    hvi_done = dig_registers[config.hvi_done_name]
    num_cycles_seg = dig_registers[config.num_cycles_seg_name]
    num_cycles_since_config = dig_registers[config.num_cycles_since_config_name]

    vi_1d_read = vi_1d.read()
    vf_1d_read = vf_1d.read()
    # slew_time_read = slew_time.read()
    sweep_direction_read = sweep_direction.read()
    neg_counter_read = neg_counter.read()
    # awg_debug_read = awg_debug.read()
    voltage_channel_1d_read = voltage_channel_1d.read()
    loop_counter_read = loop_counter_1d.read()
    dig_debug_read = dig_debug.read()
    step_counter_1d_read = step_counter_1d.read()

    logger.info("Vi 1D: {}".format(vi_1d_read))
    logger.info("Vf 1D: {}".format(vf_1d_read))
    # logger.info("Slew Time: {}".format(slew_time_read))
    logger.info("Neg counter: {}".format(neg_counter_read))
    logger.info("Init Voltage Ch{}: {}".format(config.AWG_channel_1d, voltage_channel_1d_read))
    # logger.info("AWG Debug: {}".format(awg_debug_read))
    logger.info("Step counter: {}".format(step_counter_1d_read))
    logger.info("Loop counter: {}".format(loop_counter_read))
    # logger.info("AWG Debug: {}".format(awg_debug_read))
    logger.info("DIG Debug: {}".format(dig_debug_read))

    if config.use_QD_emulator:
        conversion_factor = 2**-12
    else:
        conversion_factor = float(config.fullscale)/(2.**15 -1)

    buffer = np.array([])
    if average_data:
        averaged_data = np.empty(config.num_steps_1d)
        averaged_data[:] = np.nan
    else:
        measured_data = np.empty(config.acquisition_points)
        measured_data[:] = np.nan
    averaged_data_index = 0 # first empty slot in the averaged_data array
    x = np.linspace(config.vi_1d, config.vf_1d_internal, config.num_steps_1d)
    readPoints = 0
    old_readPoints = 0
    timeout_counter = 0
    next_print = 0 # 0.3
    t=0
    timeout = 1000 # [ms]
    if verbose:
        level = logging.INFO
    else:
        level = logging.DEBUG
    start_time = time.time()
    cycles_per_segment, num_segments = calc_num_cycles_per_segment(config.num_cycles, config.acquisition_points_per_cycle, config.use_QD_emulator)
    segments_measured = 0
    logger.info("Number of cycles: {}".format(config.num_cycles))
    logger.info("Cycles per segment: {}".format(cycles_per_segment))
    logger.info("Number of segments: {}".format(num_segments))

    # Define stop event and set to false even if not averaging
    stop_event = Event()
    stop_event.clear()
    
    if plot_pyqtgraph and PYQTGRAPH_INSTALLED:
        pqt.mkQApp()
        win = QtWidgets.QWidget()
        graph_widget = pqt.GraphicsLayoutWidget(show=True)
        graph_widget.setWindowTitle('Livetrace')
        graph = graph_widget.addPlot()
        graph.setClipToView(True)
        graph.setLabel('bottom', 'Voltage', 'V')
        graph.setLabel('left', 'Signal', 'a.u.')
        trace = graph.plot()

        # Create a grid layout to manage the widgets size and position
        layout = QtWidgets.QGridLayout()
        win.setLayout(layout)

        # Add widgets to the layout in their proper positions
        stop_button = QtWidgets.QPushButton('Stop')
        stop_button.clicked.connect(lambda: stop_event.set())
        layout.addWidget(stop_button, 0, 0)  # button goes in upper-left
        layout.addWidget(graph_widget, 0, 1, 3, 1)  # plot goes on right side, spanning 3 rows

        graph_widget.resize(800, 800)
        win.show()

        # Start plotting
        app = QtWidgets.QApplication.instance()
        config.win = win
    else:
        fig = plt.figure()
        ax = fig.add_subplot(111)
        if average_data:
            line1, = ax.plot(x[:averaged_data_index], averaged_data[:averaged_data_index], 'r-') # Returns a tuple of line objects, thus the comma
        else:
            line1, = ax.plot(x[:readPoints], measured_data[:readPoints], 'r-')
        ax.autoscale()
        ax.relim()

        # Add button to turn autoscale on/off on the figure
        ax_autoscale_toggle = plt.axes([0.75, 0.95, 0.2, 0.04])
        button_autoscale_toggle = Button(ax_autoscale_toggle, 'Autoscale Off')
        autoscale_enabled = [True]  # Use a mutable type like list to allow the inner function to modify this variable

        def toggle_autoscale(event):
            autoscale_enabled[0] = not autoscale_enabled[0]
            if autoscale_enabled[0]:
                button_autoscale_toggle.label.set_text('Autoscale Off')
            else:
                button_autoscale_toggle.label.set_text('Autoscale On')
            plt.draw()

        button_autoscale_toggle.on_clicked(toggle_autoscale)

        # Modify the autoscale function to check if autoscaling is enabled
        def autoscale(event):
            if autoscale_enabled[0]:
                ax.autoscale(enable=True)
                ax.relim()
                plt.draw()
            elif not autoscale_enabled[0]:
                ax.autoscale(enable=False) 

        button_autoscale_toggle.on_clicked(autoscale)

        # Add stop button to the figure
        stop_event = Event()
        ax_stop = plt.axes([0.65, 0.95, 0.1, 0.04])
        button_stop = Button(ax_stop, 'Stop')
        def stop(event):
            hvi.stop()
            stop_event.set()
        button_stop.on_clicked(stop)

        config.win = None # return None if not using pyqtgraph

    while (readPoints < config.acquisition_points or hvi_done.read() == 0) and not stop_event.is_set():
        t = time.time() - start_time

        # Live plotting
        if plot_pyqtgraph and PYQTGRAPH_INSTALLED:
            if average_data:
                trace.setData(x[:averaged_data_index], averaged_data[:averaged_data_index])
            else:
                trace.setData(x[:readPoints], measured_data[:readPoints])
        else:
            if average_data:
                line1.set_xdata(x[:averaged_data_index])
                line1.set_ydata(averaged_data[:averaged_data_index])
            else:
                line1.set_xdata(x[:readPoints])
                line1.set_ydata(measured_data[:readPoints])
            ax.relim()
            ax.autoscale(enable=None)
            plt.draw()

        QtWidgets.QApplication.processEvents(QtCore.QEventLoop.AllEvents, 10)

        # if t > next_print:
        voltage_channel_1d_read = voltage_channel_1d.read()
        sweep_direction_read = sweep_direction.read()
        # awg_debug_read = awg_debug.read()
        loop_counter_read = loop_counter_1d.read()
        dig_debug_read = dig_debug.read()

        logger.log(level, "Voltage Ch{}: {} | Sweep direction: {}".format(config.AWG_channel_1d, voltage_channel_1d_read, sweep_direction_read))
        logger.log(level, "Loop counter: {} | DIG Debug: {}".format(loop_counter_read, dig_debug_read))
        logger.log(level, "Read points: {}".format(readPoints))
        next_print = next_print + config.print_interval

        # TODO: Add timeout for measurement, can be trigged by accident for slow measurements for the moment
        # if readPoints == old_readPoints and readPoints > 0: # Check for measurement timeout only after the measurement has started
        #     timeout_counter = timeout_counter + 1
        #     if timeout_counter > round(config.max_time/config.print_interval):
        #         config.logger.debug("Timeout during measurement")
        #         break
        # old_readPoints = readPoints
        if countdown: print("Progress: {}%, Measurement time: {:.01f}".format(round(readPoints/config.acquisition_points*100), t), end='\r')

        ready_pts = dig_module.instrument.DAQcounterRead(DAQ_channel)
        acquisition_points_per_cycle = config.acquisition_points_per_cycle
        if ready_pts > 0:
            data = dig_module.instrument.DAQread(DAQ_channel, ready_pts, timeout) # return a Numpy array
            if not average_data:
                measured_data[readPoints:readPoints+ready_pts] = data*conversion_factor
            else:
                # Add buffer before data
                if buffer.size > 0:
                    data = np.append(buffer, data)
                    buffer = np.array([])
                if data.size >= acquisition_points_per_cycle:
                    # Find the number of points that fill the buffer and average them directly
                    nb_filled_buffers = data.size // acquisition_points_per_cycle
                    averaged_data[averaged_data_index:averaged_data_index+nb_filled_buffers] = np.mean(data[:nb_filled_buffers*acquisition_points_per_cycle].reshape((nb_filled_buffers, acquisition_points_per_cycle)), axis=1)*conversion_factor
                    averaged_data_index = averaged_data_index + nb_filled_buffers

                    # Move the remaining data to the buffer
                    buffer = data[nb_filled_buffers*acquisition_points_per_cycle:]
                else:
                    # Move data to buffer
                    buffer = data

            readPoints = readPoints + ready_pts
            config.logger.debug("{}/{} points read on ch{}".format(readPoints, config.acquisition_points, DAQ_channel))

        else:
            config.logger.debug("Checking if a full segment of data has been measured.")
            # Check if a complete segment of data has been measured
            num_cycles_seg_read = num_cycles_seg.read()
            num_cycles_since_config_read = num_cycles_since_config.read()
            config.logger.debug("Number of cycles since config / in segment: {} / {}".format(num_cycles_since_config_read, num_cycles_seg_read))
            if num_cycles_since_config_read >= num_cycles_seg_read:
                segments_measured = segments_measured + 1
                config.logger.info("Segment {} of {} measured.".format(segments_measured, num_segments))
                if segments_measured == num_segments - 1: # if we are measuring the second last segment
                    # Calculate the number of cycles for the last segment
                    remaining_cycles = config.num_cycles - cycles_per_segment*(num_segments - 1)
                    config.logger.info("Last segment will have {} cycles.".format(remaining_cycles))
                    configure_digitizer(config, dig_module, num_cycles_override=remaining_cycles)
                else:
                    configure_digitizer(config, dig_module)

                # Reset the number of cycles read since config
                num_cycles_since_config.write(0)
                config.logger.debug("Num cycles since config register reset to 0.")

    if countdown: print("")

    # Final live plot update
    if not (plot_pyqtgraph and PYQTGRAPH_INSTALLED):
        if average_data:
            line1.set_xdata(x[:averaged_data_index])
            line1.set_ydata(averaged_data[:averaged_data_index])
        else:
            line1.set_xdata(x[:readPoints])
            line1.set_ydata(measured_data[:readPoints])
        ax.relim()
        ax.autoscale(enable=None)
        plt.draw()

    QtWidgets.QApplication.processEvents(QtCore.QEventLoop.AllEvents, 10)

    vi_1d_read = vi_1d.read()
    vf_1d_read = vf_1d.read()
    # slew_time_read = slew_time.read()
    sweep_direction_read = sweep_direction.read()
    neg_counter_read = neg_counter.read()
    # awg_debug_read = awg_debug.read()
    voltage_channel_1d_read = voltage_channel_1d.read()
    loop_counter_read = loop_counter_1d.read()
    dig_debug_read = dig_debug.read()
    step_counter_1d_read = step_counter_1d.read()

    logger.info("Vi 1D: {}".format(vi_1d_read))
    logger.info("Vf 1D: {}".format(vf_1d_read))
    # logger.info("Slew Time: {}".format(slew_time_read))
    logger.info("Neg counter: {}".format(neg_counter_read))
    logger.info("Init Voltage Ch{}: {}".format(config.AWG_channel_1d, voltage_channel_1d_read))
    logger.info("Step counter: {}".format(step_counter_1d_read))
    logger.info("Loop counter: {}".format(loop_counter_read))
    # logger.info("AWG Debug: {}".format(awg_debug_read))
    logger.info("DIG Debug: {}".format(dig_debug_read))

    if stop_event.is_set():
        logger.info("HVI execution stopped by user!")
    elif hvi_done.read() == 1:
        logger.info("HVI execution completed successfully!")
    else:
        logger.info("HVI execution not completed...")

    if readPoints < config.acquisition_points:
        config.logger.warning("MISSING DATA! Measured only {}/{} points.".format(readPoints, config.acquisition_points))
    else:
        config.logger.info("Measured {}/{} points".format(readPoints, config.acquisition_points))

    config.logger.info("Measurement done in {:.04f}s".format(t))

    if average_data:
        return averaged_data
    else:
        return measured_data

#%%
# Main Program
######################################

def run_experiment(verbose=False, plot_pyqtgraph=False):
    """Function to run a 1D sweep with HVI.

    Parameters
    ----------
    verbose : bool, optional
        Allows functions to print more information about the execution, by default False.
    plot_pyqtgraph : bool, optional
        Enables live plotting using pyqtgraph, by default False. If False, the code will use matplotlib for plotting.
    """
    try:
        # Load configuration file
        config = ApplicationConfig1D.from_yaml(os.path.join(os.path.dirname(__file__), "experiment_config_Sweeper1D.yaml"))

        # Checks flags defining if the code executes on HW/Simulation, SD1
        if config.hardware_simulated:
            config.logger.info("Code running in Simulation Mode")

        # if config.loadBitstream:
        #     set_voltages_to_zero(config)

        # Open modules and load bitstreams
        # Returns a dictionary of module objects whose keys are the HVI engine names
        module_dict = open_modules(config)

        # Prepare awg module dict
        awg_module_dict = module_dict.copy()
        for engine_name in list(awg_module_dict.keys()):
            module = awg_module_dict[engine_name]
            if isinstance(module.instrument, keysightSD1.SD_AIN):
                awg_module_dict.pop(engine_name)

        awg_module = module_dict[config.main_awg_engine_name]
        load_awg(config, awg_module, reset_voltages=False)
        digitizer_module = module_dict[config.main_dig_engine_name]
        load_digitizer(config, digitizer_module)

        # Configure Digitizer
        configure_digitizer(config, module_dict[config.main_dig_engine_name])
        # Configure AWG
        for engine_name, module in awg_module_dict.items():
            configure_awg(config, module)

        ######################################
        # System definition
        ######################################
        # Create system definition object
        my_system = kthvi.SystemDefinition("MySystem")
        # Define your system, HW platform, add HVI resources
        define_hvi_resources(my_system, module_dict, config)


        ######################################
        # Program HVI sequences
        ######################################
        config.logger.info("Programming the HVI sequences...")
        # Create sequencer object
        sequencer = kthvi.Sequencer("MySequencer", my_system)
        
        # Program the HVI sequence
        define_awg_registers_1d(sequencer, awg_module, config) # Define registers within the scope of the outmost sync sequence
        define_dig_registers_1d(sequencer, digitizer_module, config)

        instruction_label = config.instruction_name.unique("Initialize registers")
        sync_block = sequencer.sync_sequence.add_sync_multi_sequence_block(instruction_label, 30)
        initialize_awg_registers_1d(sync_block, awg_module, config)
        initialize_dig_registers_1d(sync_block, digitizer_module, config)
        
        sweeper_1d(sequencer, awg_module, digitizer_module, config)
        set_hvi_done(sequencer, digitizer_module, config)
        
        # Export the programmed sequence to text
        export_hvi_sequences(sequencer, os.path.join(os.path.dirname(os.path.realpath(__file__)), r".\Sweeper1D_KS2201A.txt"))
        
        ########################################
        # Compile, Load to HW, Run HVI Sequence
        ########################################
        try:
            config.logger.info("Compiling HVI sequence...")
            hvi = sequencer.compile()
            config.logger.info('Compilation completed successfully!')
        except kthvi.CompilationFailed as err:
            config.logger.exception('Compilation failed! {}'.format(err))
            raise

        config.logger.info("This HVI needs to reserve {} PXI trigger resources to execute".format(len(hvi.compile_status.sync_resources)))

        # Load HVI to HW: load sequences, configure actions/triggers/events, lock resources, etc.
        hvi.load_to_hw()
        config.logger.info("HVI Loaded to HW")

        # Send the cross-capacitance matrix to the FPGA
        if config.use_virtual_gates:
            # send_CC_matrix(config, module_dict[config.main_awg_engine_name], CC_matrix = np.array([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]))
            DQD_CC_matrix = np.array([[1,0,-0.43,0], [0,1,0,0], [-0.23,0,1,0], [0,0,0,1]])
            send_CC_matrix(config, module_dict, hvi, CC_matrix = DQD_CC_matrix)

        # Execute HVI in non-blocking mode
        # This mode allows SW execution to interact with HVI execution
        hvi.run(hvi.no_wait)
        config.logger.info("HVI Running...")

        # User-controlled HVI execution
        if config.hardware_simulated:
            config.logger.info("Simulation completed successfully")
        else:
            average_data = True
            countdown = True
            DAQ_channel = 1
            data = interact_with_hvi(hvi, awg_module, digitizer_module, DAQ_channel, config, config.logger, verbose, average_data, countdown, plot_pyqtgraph)

        # Stopping the HVI program
        hvi.stop()

        # Plot acquisition data
        plt.figure()
        plt.plot(np.linspace(config.vi_1d, config.vf_1d, config.num_steps_1d), data, 'b-')
        plt.show()

        return config.win

    except Exception as error:
        config.logger.exception(error)
        # raise
    
    finally:
        if "hvi" in globals() or "hvi" in locals():
            if hvi.is_running():
                hvi.stop()
                config.logger.info("HVI stopped")
            # Release HW resources once HVI execution is completed
            hvi.release_hw()
            config.logger.info("Releasing HW...")
        
        # Close all modules at the end of the execution
        if "module_dict" in globals() or "module_dict" in locals():
            for engine_name in module_dict:
                module_dict[engine_name].instrument.close()
            config.logger.info("PXI modules closed")

if __name__ == "__main__":
    plt.ion()
    win = run_experiment(verbose=False, plot_pyqtgraph=False)
    plt.show(block=True)
    