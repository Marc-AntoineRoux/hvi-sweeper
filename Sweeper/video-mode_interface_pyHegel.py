import sys
import os
from PyQt5.QtWidgets import QMainWindow, QApplication, QVBoxLayout
from PyQt5.QtCore import QTimer, pyqtSignal, QThread
from PyQt5.QtGui import QCloseEvent
from PyQt5 import uic
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt
import numpy as np
from Video_mode_UI.ui.video_mode_interface import Ui_MainWindow  # Import .py file generated by pyuic5
from time import sleep, time
from Sweeper2D_KS2201A import ApplicationConfig2D, prepare_first_diagram, measure_diagram
from KS2201A_lib import  open_modules, load_awg, load_digitizer, initialize_logging, stop_logging, release_all_modules, set_voltages_to_zero, update_vg_registers, send_CC_matrix
import datetime

class WorkerThread(QThread):
    sig_instrument = pyqtSignal(np.ndarray)

    def __init__(self, main_window, parent=None):
        super(WorkerThread, self).__init__(parent)
        self.main_window = main_window
        self.is_stopped = False
        self.timeout = 40 # emulator can't run forever
        self.simulation_start_time = time()

    def stop(self):
        self.is_stopped = True

    def run(self):
        while True and not self.is_stopped and (time()-self.simulation_start_time) < self.timeout:
            self.main_window.config.logger.info("loop time: {:.01f}".format(time()-self.simulation_start_time))
            start_time = time()
            self.main_window.on_sweep_step_changed()
            self.main_window.on_gate_step_changed()
            self.main_window.on_zoom_step_changed()

            # Check if vi, vf or gate changed
            if (self.main_window.config.vi_1d != self.main_window.old_vi_1d) or (self.main_window.config.vf_1d != self.main_window.old_vf_1d) or (self.main_window.config.vi_2d != self.main_window.old_vi_2d) or (self.main_window.config.vf_2d != self.main_window.old_vf_2d) or (self.main_window.gate_value != self.main_window.old_gate_value):
                self.main_window.average_number = 0
                self.main_window.old_vi_1d = self.main_window.config.vi_1d
                self.main_window.old_vf_1d = self.main_window.config.vf_1d
                self.main_window.old_vi_2d = self.main_window.config.vi_2d
                self.main_window.old_vf_2d = self.main_window.config.vf_2d
                self.main_window.old_gate_value = self.main_window.gate_value
      
            header = self.main_window.header + "\n" + str(self.main_window.config) + "\n" + "Average number: {}".format(self.main_window.average_number+1)
            data = self.main_window.measure_func(self.main_window.config, self.main_window.module_dict, self.main_window.hvi, self.main_window.config.DAQ_channels_list, self.main_window.max_time, self.main_window.countdown, self.main_window.live_plotting, self.main_window.average_data, self.main_window.nb_averaging, self.main_window.save_data, header)
            
            if self.main_window.average_number == 0:
                data_sum = data
            else:
                data_sum = data_sum + data

            self.main_window.average_number += 1
            self.main_window.averageLabel.setText("Average: {}".format(self.main_window.average_number))
            averaged_data = (data_sum.reshape((self.main_window.config.num_steps_2d, self.main_window.config.num_steps_1d))/self.main_window.average_number)
            averaged_data = (np.gradient(averaged_data, axis=1) + np.gradient(averaged_data, axis=0))/2
            self.sig_instrument.emit(averaged_data)
            
            execution_time = time() - start_time
            min_frame_time = 0.5
            if execution_time < min_frame_time:
                sleep(min_frame_time - execution_time)

        if time()-self.simulation_start_time >= self.timeout:
            self.main_window.config.logger.info("Timeout reached. Stopping the simulation...")
                
                

class MainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, measure_func, config, module_dict, hvi, max_time=20, countdown=False, live_plotting=False, average_data=True, nb_averaging=1, save_data=False, database_folder=r"Data_HVI", save_filename="Sweeper2D_video_{}".format(datetime.datetime.now().strftime("%Y%m%d-%H%M%S-%f")), header="", parent=None):
        super(MainWindow, self).__init__(parent)
        ui_path = r"Video_mode_UI\ui\video_mode_ui.ui"
        uic.loadUi(ui_path, self)

        # Define initial parameters
        self.measure_func = measure_func
        self.config = config
        self.module_dict = module_dict
        self.hvi = hvi
        self.max_time = max_time
        self.countdown = countdown
        self.live_plotting = live_plotting
        self.average_data = average_data
        self.nb_averaging = nb_averaging
        self.save_data = save_data
        self.database_folder = database_folder
        self.save_filename = save_filename
        self.header = header

        self.figure = Figure()
        self.canvas = FigureCanvas(self.figure)  # create canvas to plot on

        self.layout = QVBoxLayout(self.plotWidget)
        self.layout.addWidget(self.canvas) # add canvas to layout

        # Buttons
        self.leftButton.clicked.connect(self.left)
        self.rightButton.clicked.connect(self.right)
        self.upButton.clicked.connect(self.up)
        self.downButton.clicked.connect(self.down)
        self.plusButton.clicked.connect(self.plus)
        self.minusButton.clicked.connect(self.minus)
        self.zoom_inButton.clicked.connect(self.zoom_in)
        self.zoom_outButton.clicked.connect(self.zoom_out)
        self.stopButton.clicked.connect(self.stop)

        # Steps
        self.sweep_step = 0.01
        self.sweep_stepLine.setText(str(self.sweep_step))
        self.gate_step = 0.01
        self.gate_stepLine.setText(str(self.gate_step))
        self.zoom_step = 0.01
        self.zoom_stepLine.setText(str(self.zoom_step))
        self.gate_value = 0.0

        # Save copy of the initial config
        self.old_vi_1d = self.config.vi_1d
        self.old_vf_1d = self.config.vf_1d
        self.old_vi_2d = self.config.vi_2d
        self.old_vf_2d = self.config.vf_2d
        self.old_gate_value = self.gate_value

        # Average label
        self.average_number = 0
        self.averageLabel.setText("Average: {}".format(self.average_number))

        self.ax = self.figure.add_subplot(111)
        z = np.empty((self.config.num_steps_2d, self.config.num_steps_1d))
        z[:] = np.nan

        self.im = self.ax.imshow(z, cmap='viridis', extent=[self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d], aspect='auto', origin='lower')
        self.cbar = self.figure.colorbar(self.im)
        self.cbar.set_label("Signal (a.u.)")
        if self.config.use_virtual_gates:
            self.im.set_clim(0, 0.06)
        else:
            self.im.set_clim(0, 0.12)
        self.ax.set_xlabel('Vg1 (V)')
        self.ax.set_ylabel('Vg2 (V)')
        self.figure.subplots_adjust(left=0.15)  # adjust the left spacing

        self.min_data = None
        self.max_data = None

        self.canvas.draw()

        self.thread = WorkerThread(self)
        self.thread.sig_instrument.connect(self.plot_data)
        self.thread.start() # run function is called

        self.show()

    def plot_data(self, data):
        self.im.set_data(data)
        if self.min_data is None:
            self.min_data = np.nanmin(data)
        if self.max_data is None:
            self.max_data = np.nanmax(data)
        if np.nanmin(data) < self.min_data:
            self.min_data = np.nanmin(data)
        if np.nanmax(data) > self.max_data:
            self.max_data = np.nanmax(data)

        if self.config.use_virtual_gates:
            self.im.set_clim(0, 0.06)
        else:
            self.im.set_clim(0, 0.12)
        self.canvas.draw()
    
    def on_sweep_step_changed(self):
        new_sweep_step = self.sweep_stepLine.text()
        new_sweep_step.replace(',', '.')
        try:
            new_sweep_step = float(new_sweep_step)
            self.sweep_step = new_sweep_step
        except Exception as error:
            print(error)
            self.sweep_stepLine.setText(str(self.sweep_step))

    def get_sweep_step(self):
        return self.sweep_step
    
    def on_gate_step_changed(self):
        new_gate_step = self.gate_stepLine.text()
        new_gate_step.replace(',', '.')
        try:
            new_gate_step = float(new_gate_step)
            self.gate_step = new_gate_step
        except Exception as error:
            print(error)
            self.gate_stepLine.setText(str(self.gate_step))

    def get_gate_step(self):
        return self.gate_step
    
    def on_zoom_step_changed(self):
        new_zoom_step = self.zoom_stepLine.text()
        new_zoom_step.replace(',', '.')
        try:
            new_zoom_step = float(new_zoom_step)
            self.zoom_step = new_zoom_step
        except Exception as error:
            print(error)
            self.zoom_stepLine.setText(str(self.zoom_step))

    def get_zoom_step(self):
        return self.zoom_step
    
    def left(self):
        self.config.vi_1d -= self.sweep_step
        self.config.vf_1d -= self.sweep_step
        self.im.set_extent([self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d])
        self.canvas.draw()

    def right(self):
        self.config.vi_1d += self.sweep_step
        self.config.vf_1d += self.sweep_step
        self.im.set_extent([self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d])
        self.canvas.draw()

    def up(self):
        self.config.vi_2d += self.sweep_step
        self.config.vf_2d += self.sweep_step
        self.im.set_extent([self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d])
        self.canvas.draw()

    def down(self):
        self.config.vi_2d -= self.sweep_step
        self.config.vf_2d -= self.sweep_step
        self.im.set_extent([self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d])
        self.canvas.draw()

    def plus(self):
        self.gate_value += self.gate_step
        if abs(self.gate_value) < 1e-9: self.gate_value = 0.0
        self.gateLabel.setText("{:.03f}".format(self.gate_value))

    def minus(self):
        self.gate_value -= self.gate_step
        if abs(self.gate_value) < 1e-9: self.gate_value = 0.0
        self.gateLabel.setText("{:.03f}".format(self.gate_value))

    def zoom_in(self):
        self.config.vi_1d += self.zoom_step/2.0
        self.config.vf_1d -= self.zoom_step/2.0
        self.config.vi_2d += self.zoom_step/2.0
        self.config.vf_2d -= self.zoom_step/2.0
        self.im.set_extent([self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d])
        self.canvas.draw()

    def zoom_out(self):
        self.config.vi_1d -= self.zoom_step/2.0
        self.config.vf_1d += self.zoom_step/2.0
        self.config.vi_2d -= self.zoom_step/2.0
        self.config.vf_2d += self.zoom_step/2.0
        self.im.set_extent([self.config.vi_1d, self.config.vf_1d, self.config.vi_2d, self.config.vf_2d])
        self.canvas.draw()

    def stop(self):
        self.thread.is_stopped = True

    def closeEvent(self, event: QCloseEvent):
        print("Closing the application...")
        self.thread.stop()  # stop the thread
        event.accept()  # let the window close

    
def start_video_mode_UI(measure_func, config, awg_module, dig_module, hvi, header):
    #app = QApplication(sys.argv) # remove in iPython
    main = MainWindow(measure_func, config, awg_module, dig_module, hvi, header)
    main.show()
    #sys.exit(app.exec_()) # remove in iPython

if __name__ == '__main__':
    # Logging setup
    log_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), "Logs", "Video-mode_interface")
    logger, console_handler, file_handler = initialize_logging(log_dir, "Video-mode")

    config = ApplicationConfig2D.from_yaml(r"Sweeper\experiment_config_video_mode.yaml")
    config.logger = logger
    config.console_handler = console_handler
    config.file_handler = file_handler
    config.DAQ_channels_list = [1]

    try:
        module_dict = open_modules(config)
        awg_module = module_dict[config.main_awg_engine_name]
        load_awg(config, awg_module, reset_voltages=False)

        if config.secondary_awg_engine_name != config.main_awg_engine_name:
            secondary_awg_module = module_dict[config.secondary_awg_engine_name]
            load_awg(config, secondary_awg_module, reset_voltages=False)
        else:
            secondary_awg_module = module_dict[config.main_awg_engine_name]

        dig_module = module_dict[config.main_dig_engine_name]
        load_digitizer(config, dig_module)

        awg_module.instrument.channelOffset(1, 0)
        awg_module.instrument.channelOffset(2, 0)

        hvi = prepare_first_diagram(config, module_dict, awg_module, dig_module, secondary_awg_module)

        if config.use_virtual_gates == True:
            # Set all voltages to zero
            set_voltages_to_zero(config, awg_module)
            set_voltages_to_zero(config, secondary_awg_module)
            update_vg_registers(config, module_dict, hvi)

            # Send identity matrix to AWG 
            config.logger.info("Sending CC matrix to FPGA.")
            CC_matrix = np.array([  [1, 0, 0, 0, 0, -0.16, 0, 0],
                                    [0, 1, 0, 0, 0, 0, 0, 0],
                                    [0, 0, 1, 0, 0, 0, 0, 0],
                                    [0, 0, 0, 1, 0, 0, 0, 0],
                                    [0, 0, 0, 0, 1, 0, 0, 0],
                                    [-0.14, 0, 0, 0, 0, 1, 0, 0],
                                    [0, 0, 0, 0, 0, 0, 1, 0],
                                    [0, 0, 0, 0, 0, 0, 0, 1]])

            send_CC_matrix(config, module_dict, hvi, CC_matrix)
            update_vg_registers(config, module_dict, hvi)

        app = QApplication(sys.argv)
        main = MainWindow(measure_diagram, config, module_dict, hvi, header="QD emulator")
        sys.exit(app.exec_())

    except Exception as error:
        logger.exception(error)
        # raise

    finally:
        logger.info("Releasing all modules...")
        if "hvi" in globals() or "hvi" in locals():
            if hvi.is_running():
                hvi.stop()
                config.logger.info("HVI stopped")
            # Release HW resources once HVI execution is completed
            hvi.release_hw()
            config.logger.info("Releasing HW...")
        
        # Close all modules at the end of the execution
        if "module_dict" in globals() or "module_dict" in locals():
            for engine_name in module_dict:
                module_dict[engine_name].instrument.close()
            config.logger.info("PXI modules closed")


